---
title: "Getting started with R - Code and exercises"
author: "Dr. Carina Nigg & Dr. Judith Boumann"
date: 10 January 2025
format:
  html:
   toc: true
   toc-expand: 1
   toc-title: Contents
   toc-location: left
   number-sections: true
   embed-resources: true
---

# Introduction

The goal of this code and exercises is to...

-   Import and inspect data in R

-   Learn the basics of data cleaning and wrangling using tidyverse

-   Implement basic operations and summaries in R

-   Gain hands-on experience through exercises

To achieve those goals, you will shortly work with data from Basel on Covid vaccinations to check data structure and check missings. For data wrangling and exploration, you will work with data from the National Health and Nutrition Examination Survey (NHANES), a national survey that measures every few years health and nutrition of adults and children in the US, including survey data, health exams, and laboratory tests (<https://wwwn.cdc.gov/nchs/nhanes/>). Before we get started with importing the data, we have to prepare our environment.

# Set-up R environment

Essential steps to set-up your R-environment include

-   Set directors

-   Load required packages

## Set directories

The ISPM usually uses a similar folder structure, but check with your work group. We recommend that you use a consistent folder structure within your work group. This ensures that everyone can easily navigate everyone's folders, e.g., if a co-author has to do a revise & res-submit. **For research data, make sure to choose a folder on the ISPM-server - don't work with the data on your desktop!**

A typical structure looks like this:

-   **01_oridata**: Here you store all original files. DO NOT ALTER THIS DATA! It's essential that you can always come back to the original dataset. R doesn't overwrite original data unless you explicitly export a dataframe and use the same name as the original file. However, it still makes sense to have this folder so that everyone knows where the data is that you started originally with.

-   **02_data:** It can make sense that you create a dataframe and export this, e.g., as an excel file. Maybe after you have run all your analysis, you want to store a final version of your dataset that you could also share with others, e.g., when providing a dataset together with your publication, or sharing it for meta-analysis.

-   **03_code**: Here you should store all your R-script / markdown / qmd-files etc. In this class, we only work with one script. 

-   **04_output:** Here you store all your output files (e.g., tables, figures).

To get started on this

1.  Select a folder on your computer where you will set up the mentioned folder structure.

2.  Copy the code below into your R script.

3.  Replace the path in the code below with the path where you want to set up the folder structure. Run the code. Check in your folder if the structure was created. Check if your project root directory is set to the path you want it to be.

```{r set directories and project folders}

# Set the project root directory

# REPLACE THIS PATH WITH THE PATH WHERE YOU SET UP THE FOLDER STRUCTURE
d_proj <- "C:/Users/cn23r745/OneDrive - Universitaet Bern/_Teaching/Introduction_to_R/Code/getting_started_with_R/data"

# Basic folders
# Directory for original data
d_oridata <- file.path(d_proj, "01_oridata")
# Directory for edited data
d_data <- file.path(d_proj, "02_data")
# Directory for R scripts
d_code <- file.path(d_proj, "03_code")
# Directory for R output
d_output <- file.path(d_proj, "04_output")


## This code below creates the folders in case you haven't set them up yet

# Create a vector with all directories
dirs <- c(d_oridata, d_data, d_code, d_output)

# Loop through the directories and create them if they don't exist
for (dir in dirs) {
  if (!dir.exists(dir)) {
    dir.create(dir, recursive = TRUE)
  }
}

```

```{r}
getwd()
```

4.  Save the script with a title of your choice in the folder "03_script". Click on File -\> Save as... -\> navigate to 03_script.

## Install and load packages

Install and load essential packages in the beginning. The easiest way to do this looks like this:

```{r}
#| eval: false

# Install package
install.packages("tidyverse")

# Load package
library(tidyverse)

```

Due to the large number of R packages out there, it can happen that functions have the same name across different packages. Therefore, you should only load the packages that you really need for your analysis. You can also unload packages again:

```{r}
unloadNamespace("tidyverse")
```

### Exercise 3: Install & load package

Install the package "pacman".

```{r Exercise 1}
#| eval: false
#| code-fold: true
#| code-summary: "Show code exercise 3"
#| output: false

# Install package
install.packages("pacman")
```

If you have multiple R packages - which is typically the case - you can use the package "pacman" to load multiple packages simultanousely. The "p_load" ensures that packages which are not installed yet will be installed. Copy the code below into your R script and run it.

```{r packages}
#| output: false
#| warning: false

# Load package "pacman"
library(pacman)

# Load all packages required for this class
pacman::p_load(tidyverse, haven, table1, readxl, writexl, labelled, summarytools) 

```

If you don't know what a package is for, there are several ways to find out:

-   Using the "Help" rider in the Output pane and typing the package into the search field, which will provide you with a brief description

-   Search for package details online in CRAN

    ```{r}
    #| eval: false

    browseURL(paste0("https://cran.r-project.org/package=", "packageName"))
    ```

-   Getting the help documentation of the package, which lists all functions and their description

    ```{r}
    #| eval: false
      
    help(package = "packageName")
    ```

### Exercise 4: Find package information

Find out what the package "readxl" is used for. List two functions of the package

```{r Exercise 2}
#| code-fold: true
#| code-summary: "Show code exercise 4"
#| output: false

# Description of readxl
browseURL(paste0("https://cran.r-project.org/package=", "readxl"))

# List functions (you can also find the description there)
# Examples: read_excel, excel_sheets
help(package = "readxl")

# Googling also works

```

Now that we are set-up with the R environment, we can start to import our data.

```{r NOT FOR CLASS PARTICIPANTS}
#| include: FALSE
#| output: FALSE

# Set system language to English
Sys.setenv(LANG = "en")

# Preparation of NHANES dataset (2017-2018) for class

## 1 Demographic data
nhanes_demo <- read_xpt(file.path(d_oridata, "DEMO_J.xpt"))
dim(nhanes_demo)

demo <- nhanes_demo %>% # select only relevant variables
        select(SEQN, RIAGENDR, RIDAGEYR, RIDRETH1, DMDEDUC2, INDHHIN2)

## 2 Examination data

# height, weight, bmi
nhanes_body <- read_xpt(file.path(d_oridata, "BMX_J.xpt"))
dim(nhanes_body)

body <- nhanes_body %>% # select only relevant variables
        select(SEQN, BMXWT, BMXHT)

# blood pressure
nhanes_bloodpressure <- read_xpt(file.path(d_oridata, "BPX_J.xpt"))
dim(nhanes_bloodpressure)

blood <- nhanes_bloodpressure %>%
         select(SEQN, BPXSY1, BPXDI1, BPXPLS)

## 3 Questionnaire data
nhanes_smoking <- read_xpt(file.path(d_oridata, "SMQ_J.xpt"))
dim(nhanes_smoking)

smoking <- nhanes_smoking %>% # select only relevant variables
           select(SEQN, SMQ020, SMQ040, SMQ900)


# Join to one dataframe
nhanes <- demo %>%
  left_join(body, by = "SEQN") %>%
  left_join(blood, by = "SEQN") %>%
  left_join(smoking, by = "SEQN")
glimpse(nhanes)

# Export to xlx file
write_xlsx(nhanes, file.path(d_data, "nhanes_for_R.xlsx"))


```

# Import & check data structure

## Import

We will now import the NHANES dataset to work with using the readxl package. Before doing this, download the excel file "nhanes_for_R.xlsx" and save it to your folder "01_oridata".

Copy the code into your script and run the code. We will assign the table that we import to the object "nhanes".

```{r import excel}

nhanes <- read_excel(file.path(d_data, "nhanes_for_R.xlsx"))

```

There are more options what we can specify when importing excel files, such as specifying certain columns or cells, or defining missing values. See the code below for what you could do.

```{r import excel options}
#| eval: false

# sheet: Specify the sheet name or number.
nhanes <- read_excel(file.path(d_data, "nhanes_for_R.xlsx"), sheet = 1)

# range: Import a specific range of cells.
nhanes <- read_excel(file.path(d_data, "nhanes_for_R.xlsx"), range = "A1:D100")

# col_names: Specify if the first row contains column names.
# TRUE (default): First row is used as column names.
# FALSE: R assigns default column names (X1, X2, etc.).
nhanes <- read_excel(file.path(d_data, "nhanes_for_R.xlsx"), col_names = FALSE)

# skip: Skip the first n rows
nhanes <- read_excel(file.path(d_data, "nhanes_for_R.xlsx"), skip = 3)

# na: Define missing values.
nhanes <- read_excel(file.path(d_data, "nhanes_for_R.xlsx"), na = c("NA", "99"))

```

There are other packages and functions for importing other data formats. Most common are:

-   **csv-files**: read.csv() (Base R) or read_csv() (readr)

-   **STATA, SAS, SPSS** (haven): read_dta (Stata files), read_sav() (SPSS files), read_sas (SAS files)

### Exercise 5: Import data

1.  Download the data "BMX_J.xpt" from GitHub and put it into your "01_oridata" folder. This is the original data file from the NHANES dataset that contains all body measures (e.g., height, weight).

2.  Find out which package you need to import an xpt-file.

3.  Import the file in R and assign it to the object "nhanes_body".

    ```{r exercise 3}
    #| code-fold: true
    #| code-summary: "Show code exercise 5"
    #| output: false

    nhanes_body <- read_xpt(file.path(d_oridata, "BMX_J.xpt"))

    ```

## Checking data structure

After you imported your data, you may want to check your data structure and get an overview. There different ways to do this:

-   **Dimensions**: Check number of rows and columns

    ```{r}

    # Dimensions (rows and columns)
    dim(nhanes)

    # Number of rows only
    nrow(nhanes)

    # Number of columns only
    ncol(nhanes)
    ```

-   **Column names**: List the names of all variables

    ```{r}

    colnames(nhanes)
    ```

-   **Data structure**: Provides overview of dataset structure, including variable types and the first few observations

    ```{r}

    # option 1
    str(nhanes)

    # option 2
    glimpse(nhanes)

    # option 3: This will open the dataset in a separate window with the first couple of hundered of rows and
    View(nhanes)
    ```

-   **Quick summary of each variable**: Gives you summary statistics for each column, including missings

    ```{r}

    summary(nhanes)
    ```

-   **Data preview**: View the first view or last few rows of your dataset

    ```{r}

    # first 6 rows
    head(nhanes)

    # last 6 rows
    tail(nhanes)

    # You can append this argument to specify the first/last number of rows you want to see:
    head(nhanes, n = 10)
    ```

-   **Check class / variable type** of your dataset / columns

    ```{r}

    # Class of the entire dataset
    class(nhanes)

    # Class of a specific column
    class(nhanes$RIAGENDR)

    # Data types of all columns
    sapply(nhanes, class)

    ```

### Exercise 6: Checking data structure of a dataset

Download the data Covid19_vaccines_Basel. This dataset has been altereda and contains some information about the number of Covid-19 vaccinations in the Canton Basel-Citiy between 2 January 2021 and July 1 2023. Find out about the following:

1.  Import the excel file Covid_19_vaccines_Basel.xlsx into R and assign it to the object "covid".

2.  How many columns does the dataset have?

3.  How many rows?

4.  Use one of the functions to get an overview of your data.

5.  What is the median of vaccinations per day? (variable `Vac_perday`)

6.  How many missings do we have for booster vaccinations? (variable `Total_vacbooster`)

7.  What is the total number of vaccinations in line 14? (variable `Total_vac`)

```{r exercise 4}
#| code-fold: true
#| code-summary: "Show code exercise 6"
#| output: false

# 1. Import the excel file Covid_19_vaccines_Basel into R
covid <- read_excel(file.path(d_oridata, "Covid19_vaccines_Basel.xlsx"))

# 2. How many columns does the dataset have?
# 6 columns
dim(covid)
ncol(covid)

# 3. How many rows?
# 915 rows
dim(covid)
nrow(covid)

# 4. Use one of the functions to get an overview of your data
str(covid) # option 1
glimpse(covid) # option 2

# 5. What is the median of vaccinations per day? (variable Vac_perday)
# 72 years
summary(covid)

# 6. How many missings do we have for booster vaccinations? (variable Total_vacbooster)
# 58
summary(covid)

# 7. What is the total number of vaccinations in line 14? (variable Total_vac)
# 15,806
head(covid, n = 14)
```

## Check missings

Checking for missing values is an essential step when importing your data. We have a small number of variables in this dataset, so you can already perform this check at this stage. If you have more variables, e.g., a large datasets with hundreds of variables/columns, it doesn't make sense to check missings for all those variables. Then it makes sense to first select the relevant variables (see next section), and then check the missings.

**Check for missing values**: Summarize missing values in the dataset

```{r}

# Total missing values
sum(is.na(nhanes))

# Missing values per column
colSums(is.na(nhanes))

# Missing values for a specific variable
sum(is.na(nhanes$BMXWT))

```

### Exercise 7: Check missing

Check the number of missings for all variables in the covid dataset.

1.  Check the number of missings for all variables in the covid dataset.
2.  Check missings only for total vaccine boosters (variable `Total_vacbooster`).

```{r Exercise 5}
#| code-fold: true
#| code-summary: "Show code exercise 7"
#| output: false

# 1. Check the number of missings for the whole covid dataset.
colSums(is.na(covid))

# 2. Check missings only for total vaccine boosters (variable Total_vacbooster).
# 684
sum(is.na(covid$Total_vacbooster))

```

# Preparing your dataset for analysis with tidyverse

The tidyverse is a collection of R packages designed to make data manipulation, exploration, and visualization simple and intuitive. These packages are designed in a similar way, making it easier to learn and apply them to your data. The core tidyverse includes several key packages, which work together seamlessly, making the tidyverse an efficient toolset for working with data analysis workflows:

-   **dplyr**: For data manipulation, such as filtering rows, selecting columns, and summarizing data.

-   **tidyr:** For tidying and reshaping data.

-   **tibble**: For simple data frames.

-   **ggplot2**: For data visualization.

-   **readr**: For importing data (e.g., .csv files)

-   **purrr**: For functional programming.

-   **stringr**: For working with strings.

-   **forcats**: For handling categorical data (factors).

**Why use the tidyverse?**

-   **Consistent Syntax:** Tidyverse functions follow a consistent pattern, making them easier to understand and use.

-   **Pipelines with %\>%:** The tidyverse encourages the use of pipelines, allowing you to chain commands together for clearer, more readable code.

-   **Ease of Learning**: Many tidyverse functions are intuitive and have helpful default settings, avoiding complex programming syntax.

-   **Community Support:** The tidyverse is widely used in the R community, so there is a wealth of documentation, tutorials, and community support available.

**Example comparing Base R and tidyverse**

Let???s say you have a dataset called `nhanes` and you want to:

1.  Filter the rows for all who are males (RIAGENDR == 1)

2.  Calculate the average weight.

[Base R]{.underline}

```{r}
mean(nhanes$BMXWT[nhanes$RIAGENDR == 1], na.rm = TRUE)
```

[Tidyverse]{.underline}

```{r}
nhanes %>%
      filter(RIAGENDR == 1) %>%
      summarize(mean_weight = mean(BMXWT, na.rm = TRUE))
```

In the tidyverse example above, the following happens:

-   **nhanes %\>%**\
    Start with the `nhanes` dataset.
-   **filter(RIAGENDR == 1) %\>%**\
    Filter the dataset where RIAGENDR == 1 is (male), and then pass this filtered dataset to the next function.
-   **summarize(mean_weight = mean(BMXWT, na.rm = TRUE))**\
    Calculate the mean of the `BMXWT` column and store it as `mean_weight`. `na.rm = TRUE` tells R to ignore/remove missing values for this operation.

**More generalized, the pipe (%\>%)...**

1.  **Takes the output from the left**: The value or object on the left side of the pipe is passed as the first argument to the function on the right side.

2.  **Sends it to the next step**: After the function on the right finishes its work, its result is sent as input to the next function in the chain.

3.  **Repeat until done**: This process continues for as many steps as you chain together.

**What you will learn today**

In this session, we will cover the most commonly used functions in the tidyverse, mostly from the "dplyr" package. These include:

-   **select:** For selecting columns

-   **filter:** For filtering rows based upon condition(s).

-   **arrange:** For sorting data

-   **rename**: For renaming variables

-   **mutate**: For creating / modifying variables.

-   **group_by** and **summarize**: For aggregating data

-   **class conversions** (e.g., **as.factor**): For converting a variable from one class into another one.

-   **if_else** and **case_if:** For categorizing data

-   **relocate**: For re-ordering variables in a dataframe

-   **relevel**: For setting a reference category.

## Select()

The select() function (from dplyr) is used to pick specific columns from a dataset. This is particularly helpful when your dataset has many variables, but you need to focus on a few for your analysis. It can be used to

-   reduce the number of columns in a dataset, making it easier to work with

-   reorganize the order of columns

-   exclude specific columns.

In this an all following examples, we will only work with a subset of variables from NHANES:

-   `SEQN`: Respondent sequence number.

-   `RIAGENDR`: Gender.

-   `RIDAGEYR`: Age.

-   `BMXWT`: Weight.

-   `BMXHT`: Height.

### Examples

**Basic selection**: This is the easiest way to choose your variables - selecting your variables by specific names. This is the dataset we will keep for other examples.

```{r}

# Select specific columns
df <- nhanes %>%
      select(SEQN, RIAGENDR, RIDAGEYR, BMXWT, BMXHT)

# Check rows and columns
dim(df)

# Preview dataset
head(df)

```

**Options**: The select-function can do a lot more and save you some time instead of specifying each variable name on its own.

-   **Reorder columns**: You can reorder columns by specifying the order

    ```{r}

    # Reorder columns
    dt<- nhanes %>%
      select(RIDAGEYR, BMXWT, BMXHT, SEQN, RIAGENDR) %>%
      head %>%
      print
    ```

-   **Select columns by range**: Use column positions to select a range

    ```{r}

    # Select columns by position
    dn <- nhanes %>%
      select(1:3) %>%
      head %>%
      print

    # Select consecutive columns using names - same result as above
    dn <- nhanes %>%
          select(SEQN:RIDAGEYR)
    head(dn)
    ```

-   **Exclude columns** using the "-" operator

    ```{r}

    # Exclude specific columns
    dn <- nhanes %>%
      select(-SEQN:-INDHHIN2)

    head(dn)
    ```

-   **Select columns by pattern:** You can select columns by pattern or name

    ```{r}

    # Select columns that start with "BMX"
    dn <- nhanes %>%
      select(starts_with("BMX"))
    head(dn)

    # Select columns that contain "AGE"
    dn <- nhanes %>%
      select(contains("AGE"))
    head(dn)

    # Select columns that end with "YR"
    dn <- nhanes %>%
      select(ends_with("YR"))
    head(dn)
    ```

### Exercise 8: Select

When writing the code for the following exercises, assign them to the object "ds".

1.  Select only the columns `SEQN`, `RIAGENDR`, and `SMQ040`.

2.  Reorder the columns to: `SMQ040`, `RIAGENDR`, `SEQN`.

3.  Exclude the `BPXSY1` and `BPXDI1` columns.

4.  Select columns that start with `BPX`.

5.  Bring two operations together using the pipe:

    a\) Select only the columns `SEQN`, `RIAGENDR`, and `SMQ040`

    b\) Reorder the columns to: `SMQ040`, `RIAGENDR`, `SEQN`

```{r}
#| code-fold: true
#| code-summary: "Show code exercise 8"
#| output: false

# 1. Select only the columns SEQN, RIAGENDR, and SMQ040.
ds <- nhanes %>%
            select(SEQN, RIAGENDR, SMQ040)

# 2. Reorder the columns to: SMQ040, RIAGENDR, SEQN.
ds <- nhanes %>%
            select(SMQ040, RIAGENDR, SEQN)

# 3. Exclude the BPXSY1 and BPXDI1 columns.
ds <- nhanes %>%
            select(-BPXSY1, -BPXDI1)

# 4. Select columns that start with "BPX".
ds <- nhanes %>%
            select(starts_with("BPX"))

# 5. Bring two operations together using the pipe
ds <- nhanes %>%
            # a) Select only the columns SEQN, RIAGENDR, and SMQ040 
            select(SEQN, RIAGENDR, SMQ040) %>%
            # b) Reorder the columns to: SMQ040, RIAGENDR, SEQN
            select(SMQ040, RIAGENDR, SEQN)
```

## Filter()

The `filter()` function (from dplyr) is used to select rows in a dataset that meet certain conditions. It's a powerful tool for narrowing down data based on specific criteria. You use it to

-   focus on relevant subsets of data for analysis.
-   exclude rows that don't meet certain criteria.
-   explore and validate data by applying logical conditions.

### Examples

**Basic filtering**: Filter rows based on a single condition

```{r}

# Filter for males only (RIAGENDR == 1)
dn <- df %>%
  filter(RIAGENDR == 1)

head(dn)

```

If you work with variables of the class "factor", you need to put the value (label) in quotation marks:

```{r}

dn <- df %>%
      mutate(RIAGENDR = as.factor(RIAGENDR)) %>% # mutate to factor variable
      filter(RIAGENDR == "1")
head(dn)
```

**Options**: There are of course more options how you can work with the filter-function.

-   **Filtering with multiple conditions**: Use & for "AND" and \| for "OR" to combine conditions

    ```{r}

    # Filter for females aged 30 or older
    dn <- df %>%
      filter(RIAGENDR == 2 & RIDAGEYR >= 30) %>%
      summary %>%
      print

    # Filter for individuals younger than 18 OR with weight above 80 kg
    dn <- df %>%
      filter(RIDAGEYR > 18 | BMXWT > 80)

    ```

-   **Filtering for missing or non-missing data**: To filter rows with missing values or exclude them

    ```{r}

    # Filter rows where weight is not missing
    dn <- df %>%
      filter(!is.na(BMXWT)) %>%
      summary %>%
      print

    # Filter rows where height is missing
    dn <- df %>%
      filter(is.na(BMXHT)) %>%
      summary %>%
      print
    ```

### Exercise 9: Filter

1.  Select the following variables: SEQN, RIAGENDR, SMQ040, BPXSY1, BPXDI1. Assign them to the object "ds".

    For the following exercises, use the dataset "ds" and assign any operations to the object "dt".

2.  Filter rows where `RIAGENDR` is 2 (female).

3.  Filter rows where `BPXSY1` (systolic blood pressure) is greater than 120 and `BPXDI1` (diastolic blood pressure) is less than 80.

4.  Combine multiple conditions with `|`: Filter rows where `RIAGENDR` is 1 (male) OR `BPXSY1` is greater than 140.

```{r}
#| code-fold: true
#| code-summary: "Show code exercise 9"
#| output: false


# 1. Select the variables SEQN, RIAGENDR, SMQ040, BPXSY1, BPXDI1
ds <- nhanes %>%
            select(SEQN, RIAGENDR, SMQ040, BPXSY1, BPXDI1)

# 2. Filter rows for people who smoke everday (SMQ040 is 1).
dt <- ds %>%
  filter(SMQ040 == 1)

# 3. Filter rows where BPXSY1 (systolic blood pressure) is greater than 120
#    and BPXDI1 (diastolic blood pressure) is less than 80.
dt <- ds %>%
  filter(BPXSY1 > 140 & BPXDI1 > 90)

# 4. Combine multiple conditions with |:
#    Filter rows where RIAGENDR is 1 (male) OR BPXSY1 is greater than 140.
dt <- ds %>%
  filter(RIAGENDR == 1 | BPXSY1 > 140)

```

## Arrange()

The `arrange()` function (dplyr package) is used to reorder rows in a dataset based on the values of one or more columns. You can sort data in ascending (default) or descending order. You use arrange to...

-   organize data for better readability
-   identify the largest, smallest, or specific range of values
-   prepare data for summary tables or reports

### Examples

**Basic sorting**: Sort rows in ascending order by a single variable

```{r}

# Sort by age (ascending order)
dn <- df %>%
  arrange(RIDAGEYR) %>%
  head %>%
  print
```

**Options**: You can adjust the function based upon your needs.

-   **Sorting in descending order**: Use desc() to sort rows in descending order

    ```{r}

    # Sort by weight (descending order)
    dn <- df %>%
      arrange(desc(BMXWT))

    head(dn)
    ```

-   **Sorting by multiple variables**: You can sort by multiple columns, specifying the order of precedence

    ```{r}

    # Sort by gender (ascending) and age (descending)
    dn <- df %>%
      arrange(RIAGENDR, desc(RIDAGEYR))

    head(dn)
    ```

-   **Sorting with missing values**: By default, arrange() places missing values (NA) at the end. You can also have them on top if needed.

    ```{r}

    # Sort by height with NA at the top
    dn <- df %>%
      arrange(desc(is.na(BMXHT)))

    head(dn)
    ```

### Exercise 10: Arrange

Use again your dataset "ds" and assign any operations to "dt".

1.  Sort the dataset by `BPXSY1` (systolic blood pressure) in ascending order.
2.  Sort the dataset by `SMQ040` (smoking status) in descending order.
3.  Filter rows where `BPXDI1` (diastolic blood pressure) is greater than 90 and sort descending by `BPXSY1`.

```{r}
#| code-fold: true
#| code-summary: "Show code exercise 10"
#| output: false

# 1. Sort the dataset by BPXSY1 (systolic blood pressure) in ascending order.
dt <- ds %>%
  arrange(BPXSY1)

# 2. Sort the dataset by SMQ040 (smoking status) in descending order.
dt <- ds %>%
  arrange(desc(SMQ040))

# 3. Filter rows where BPXDI1 (diastolic blood pressure) is greater than 90 and
#    sort descending by BPXSY1.
dt <- ds %>%
  filter(BPXDI1 > 90) %>%
  arrange(desc(BPXSY1))

```

## Rename()

The `rename()` function (from dplyr) is used to rename variables in a dataset. It allows you to provide new, meaningful names to columns while preserving the dataset's structure. You can use it to

-   To improve the readability and interpretability of your dataset.
-   To standardize variable names for consistency in analysis.
-   To simplify long or complex variable names.

We will show some examples here. To stay consistent with the codebook, we will keep working with the original variable names afterwards.

### Examples

**Basic: Renaming one variable**

```{r}

# Rename a single variable
dn <- df %>%
      rename(gender = RIAGENDR)

# View the result
colnames(dn)

```

**Options**: You can also rename multiple variables in one flow.

-   **Renaming multiple single variables at once**

    ```{r}

    # Rename multiple variables
    dn <- df %>%
        rename(
          ID = SEQN,
          gender = RIAGENDR,
          age = RIDAGEYR,
          weight = BMXWT,
          height = BMXHT
        )

    # View the results
    colnames(dn)
    ```

-   **Renaming variables based on patterns**: Add a prefix, suffix, or replace variable names that have some common patterns in their name.

    ```{r}

    # Option 1: Add a prefix to all variables
    di <- df %>%
      rename_with(~ paste0("NHANES_", .))

    # Breakdown of the rename_with code
    # ~ (tilde): In general, the tilde creates an anonymous function for rename_with to apply paste0 to each column name. In simple words, it tells R in this case "For each column name, do the following"
    # paste0: This tells R to join strings without spaces
    # ("NHANES_",): Add "NHANES_" to the beginning of each column name.
    # . : Represents each column name (a placeholder for the current column name being processed).

    # View the result
    colnames(di)



    # Option 2: Add a suffix "_new" to variables starting with "BMX"
    di <- df %>%
      rename_with(~ paste0(., "_new"), starts_with("BMX"))

    # View the updated column names
    colnames(di)


    # Option 3: Replace "BMX" with "body" in variable names
    di <- df %>%
      rename_with(~ sub("^BMX", "body", .), starts_with("BMX"))

    # Breakdown of the rename_with code
    # ~ sub: In general, this tells R to find pattern in a certain string and it with something you specify. The string pattern and replacement you specify in the following brackets.
    # ^: Indicates to look only for the start of the string.
    # "BMX": Matches the prefix BMX at the start of the column name
    # "body": This is the replacement you specify for body
    # . : Represents each column being processed
    # ("NHANES_",): Add "NHANES_" to the beginning of each column name.
    # . : Represents each column name (a placeholder for the current column name being processed).

    # View the updated column names
    colnames(di)
    ```

-   **Optional - Adding variable labels:** If you also want to label your variables, you can use the labelled-package.

    ```{r}

    # Assigning one variable label:
    var_label(dn$gender) <- "Gender of participant"
    # Check the label
    var_label(dn$gender)


    # You can also create a list and create multiple variable labels at once and assign them to a variabel:
    var_label(dn) <- list(
      ID = "Participant id",
      gender = "Gender of participant",
      age = "Age at study",
      weight = "Weight in kg",
      height = "Height in kg"
    )

    # Check labels
    var_label(dn)

    ```

### Exercise 11: Rename

Practice renaming variables using the ds-dataframe. Assign all operations to "dt".

1.  Rename `BPXSY1` to `systolicBP`.
2.  Rename `SMQ040` to `currentSmoker` and `BPXDI1` to `diastolicBP`.
3.  Use `rename_with()` to replace `BPX` with `pressure` in all variables starting with `BPX`.

```{r}
#| code-fold: true
#| code-summary: "Show code exercise 11"
#| output: false


# 1. Rename BPXSY1 to systolicBP.
dt <- ds %>%
      rename(systolicBP = BPXSY1)

# 2. Rename SMQ040 to currentSmoker and BPXDI1 to diastolicBP.
dt <- ds %>%
  rename(
    currentSmoker = SMQ040,
    diastolicBP = BPXDI1
  )

# 3. Use rename_with() to replace BPX with pressure in all variables starting with BPX.
dt <- ds %>%
  rename_with(~ sub("^BPX", "pressure", .), starts_with("BPX"))
```

## Mutate()

The `mutate()` function in the `dplyr` package is used to create new variables, modify existing ones, and perform calculations on existing data. You can use mutate to

-   derive new variables for analysis (e.g., calculate BMI)

-   recode or categorize variables (e.g., age groups)

-   perform transformations (e.g., converting units)

### Examples

-   **Creating new variables**: Add a new variable. In this example, add the variable BMI (Body Mass Index: body weight in kg / (body height in m) \^2)

    ```{r}

    # Calculate BMI
    dn <- df %>%
      mutate(BMI = BMXWT / (BMXHT / 100)^2)

    # List column names
    head(dn)
    ```

-   **Modifying existing variables**: In this example, we change age (currently in years) to months. Here, we overwrite the current age-variable. It is recommended to create a new variable

    ```{r}

    # Convert age to months
    dn <- df %>%
      mutate(RIDAGEYR = RIDAGEYR * 12) %>%
      head %>%
      print

    # Convert age to month and create a new variable
    dn <- df %>%
      mutate(age_months = RIDAGEYR * 12) %>%
      relocate(age_months, .after = RIDAGEYR) %>% # this function moves one variable after another one
      head %>%
      print
    ```

-   **Categorizing variables using if_else**: Especially handy for binary categorizations. You can do more categories by nesting multiple if_else functions.

    ```{r}

    # Categorize age into two categories
    df <- df %>%
       mutate(age_group_binary = if_else(RIDAGEYR >= 18, "adult", "child"))
    head(dn)

    # Categorize age into three categories
    df <- df %>%
        mutate(age_group_three =
                if_else(RIDAGEYR < 13, "child", 
                  if_else(RIDAGEYR >= 13 & RIDAGEYR < 18, "teenager", "adult")
                ))
    head(df)

    ```

-   **Categorizing variables using case_when:** For categorizing variables, case_when is more flexibel for multiple conditions (\> 2).

    ```{r}

    # Categorize BMI
    df <- df %>%
      mutate(BMI = BMXWT / (BMXHT / 100)^2) %>%
      mutate(BMI_category = case_when(
        BMI < 18.5 ~ "underweight",
        BMI >= 18.5 & BMI < 25 ~ "normal",
        BMI >= 25 & BMI < 30 ~ "overweight",
        BMI >= 30 ~ "obese"
      ))

    head(df, n = 20)
    ```

### Exercise 12: Mutate

Use again your dataset "ds" and assign all operations to this dataset (ds).

1.  Create a new variable called `pulse_pressure`, calculated as `BPXSY1 - BPXDI1`.

2.  Create a binary variables `smoker_status` using `if_else()`:

    -   `3` for `SMQ040` (not at all), 1 otherwise (smoking everyday / some days).

3.  Categorize `BPXSY1` (systolic blood pressure) into three groups using `case_when()`.

    -   `< 120`: "normal"

    -   `120???139`: "elevated"

    -   `??? 140`: "hypertension"

```{r}
#| code-fold: true
#| code-summary: "Show code exercise 12"
#| output: false

# 1. Create Pulse_Pressure variable
ds <- ds %>%
  mutate(pulse_pressure = BPXSY1 - BPXDI1)

# 2. Create Smoker_Status using if_else()
ds <- ds %>%
  mutate(smoker_status = if_else(SMQ040 == 3, 0, 1))

# 3. Categorize systolic blood pressure using case_when()
ds <- ds %>%
  mutate(bp_category = case_when(
    BPXSY1 < 120 ~ "normal",
    BPXSY1 >= 120 & BPXSY1 < 140 ~ "elevated",
    BPXSY1 >= 140 ~ "hypertension"
  ))
```

## Class conversions

Class conversions are essential to transform variable types. You use them to

-   prepare data for analysis (e.g., converting strings to factors for categorical variables).
-   fixing data import issues (e.g., when numeric values are read as characters).
-   customize variable types for specific functions (e.g., some models require factors).

### Examples

There are different conversions available:

-   **String (character) to factor**: To convert a character/string into a factor variable.

    ```{r}

    # Example: Convert BMI (character) to a factor
    df <- df %>%
      mutate(BMI_category = as.factor(BMI_category))

    # Check the class of the variable
    class(df$BMI_category)
    levels(df$BMI_category)

    ```

    As you can see, R orders the levels alphabetically if not specified otherwise. We can specify the level order using an adapted code:

    ```{r}

    df <- df %>%
            mutate(BMI_category = factor(BMI_category,
                                         levels = c("underweight", "normal", "overweight", "obese")))

    # Check the class of the variable
    class(df$BMI_category)
    levels(df$BMI_category)


    # Optional: If you want to set a different reference category, you can use the relevel() function
    dn <- df %>%
            mutate(BMI_category = relevel(BMI_category, ref = "normal"))
    levels(dn$BMI_category)
    ```

-   **Numeric to factor:** Useful for categorical variables stored as numbers.

    ```{r}

    # Example: Convert Gender (numeric) to a factor
    dn <- df %>%
      mutate(RIAGENDR = as.factor(RIAGENDR))
    class(dn$RIAGENDR)
    levels(dn$RIAGENDR)

    # Optionally, you can also assign value labels
    df <- df %>%
          mutate(RIAGENDR = factor(RIAGENDR,
                                   levels = c(1, 2),
                                   labels = c("male", "female")))
    # Check the result
    class(df$RIAGENDR)
    levels(df$RIAGENDR)
    nlevels(df$RIAGENDR) # Gives you the number of levels
    ```

-   **Factor to numeric**: When you import datasets, it can happen that a numeric variable is recognized as a factor variable, which you then have to change:

    ```{r}

    df <- df %>%
      mutate(RIAGENDR_incorrect = as.numeric(RIAGENDR))
    head(df)

    # Drop again
    df <- df %>%
      select(- RIAGENDR_incorrect)

    ```

### Exercise 13: Class conversions

Work again with your dataframe "ds" and assign all operations to the dataframe "ds".

1.  Convert smoker_status from numeric to a factor with the following labels:

    -   `0`: "no smoker"

    -   `1`: "current smoker"

2.  Convert the variable `bp_category` from string to factor variable. Order the levels the following: "normal", "elevated", "hypertension".

    ```{r}
    #| code-fold: true
    #| code-summary: "Show code exercise 13"
    #| output: false

    # 1. Convert SMQ040 (smoking status) from numeric to a factor with the following labels:
    ds <- ds %>%
      mutate(smoker_status = factor(smoker_status,
                            levels = c(0, 1),
                            labels = c("no smoker", "current smoker")))


    # 2. Convert the variable bp_category from string to factor variable. Order the levels the following: "normal", "elevated", "high".
    ds <- ds %>%
      mutate(bp_category = factor(bp_category,
                                  levels = c("normal", "elevated", "hypertension")))

    ```

# Exploring your dataset

Now that you prepared your dataset for analysis, we can run exploratory data analysis. We do this to uncover patterns, spot anomalies, and summarize its key characteristics. It usually involves:

-   **Descriptive statistics**: Summarizing individual variables (e.g., mean and median)

-   **Visualizations**: Exploring distributions and relationships between variables (e.g., boxplot, correlation matrix)

-   **Group comparisons**: Comparing metrics across different categories (e.g., cross-tabulations, mean by group).

We will use different packages for exploratory data analysis including tidyverse, which you already know, and the packages "table1" and "summarytools".

## Simple descriptive statistics

We will calculate some basic descriptive statistics for numeric and factor variables. There are various ways of doing this in R, we will show you a couple of options with Base R, tidyverse, and summarytools.

### Numeric variables

-   **Base R**

    ```{r}

    # Summary function for an overview of a single variable
    summary(df$RIDAGEYR, na.rm = FALSE)

    # Individual calculations
    min(df$RIDAGEYR, na.rm = TRUE)    # Minimum age
    mean(df$RIDAGEYR, na.rm = TRUE)   # Mean age
    median(df$RIDAGEYR, na.rm = TRUE) # Median age
    max(df$RIDAGEYR, na.rm = TRUE)    # Maximum age
    ```

-   **tidyverse**

    ```{r}

    # calculate basic descriptive statistics for one variable
    df %>%
      summarize(
        Min_Age = min(RIDAGEYR, na.rm = TRUE),
        Mean_Age = mean(RIDAGEYR, na.rm = TRUE),
        Median_Age = median(RIDAGEYR, na.rm = TRUE),
        Max_Age = max(RIDAGEYR, na.rm = TRUE)
      )


    # calculate basic descriptive statistics for multiple variables

    df %>%
      summarize(
        across(
          c(RIDAGEYR, BMXWT, BMXHT),
          list(
            Min = ~ min(.x, na.rm = TRUE),
            Mean = ~ mean(.x, na.rm = TRUE),
            Median = ~ median(.x, na.rm = TRUE),
            Max = ~ max(.x, na.rm = TRUE)
          ),
          .names = "{.col}_{.fn}"
        )
      )

    # The .names argument controls how the new column names are generated:
    # {.col} refers to the variable name (e.g., Variable1).
    # {.fn} refers to the function name (e.g., Min, Mean, etc.).
    # This ensures the output columns have clear and unique names.
    ```

-   **summarytools**

    ```{r}

    # Detailed descriptive statistics for RIDAGEYR (Age)
    summarytools::descr(df$RIDAGEYR)
    ```

### Factor variables

-   **Base R**

    ```{r}

    # Frequency counts for gender
    table(df$RIAGENDR)

    # Proportions (relative frequencies)
    prop.table(table(df$RIAGENDR))

    ```

-   **tidyverse**

    ```{r}

    # Frequency counts for RIAGENDR (Gender)
    df %>%
      count(RIAGENDR)

    # Add proportions
    df %>%
      count(RIAGENDR) %>%
      mutate(Proportion = n / sum(n)) #  # calculates the proportion of each category relative to the total count of observations

    ```

-   **summarytools**

    ```{r}
    freq(df$RIAGENDR)
    ```

### Numeric & factor variables

If you want to create a more comprehensive overview of both numeric and factor variables, the packages summarytools and table 1 can be very helpful.

-   **table1**: This is a useful function to create an overview of various variable types, and is a great format that you can also export to a word document.

    ```{r}

    # Descriptives for age, gender, BMI, and BMI category
    table1(~ RIAGENDR + RIDAGEYR + BMI + BMI_category,
            data = df)

    # Descriptives and omitting missings for each variable
    table1(~ RIAGENDR + RIDAGEYR + BMI + BMI_category,
            data = df,
            render.missing = NULL)

    ```

-   **summarytools**: The function "dfSummary" creates a comprehensive overview of dataframe, including basic descriptive statistics, value codings, histogramms / bar plots, and missings.

    ```{r}

    # Summary of dataframe df
    dfSummary(df)

    # Summary of dataframe df as html-output
    view(dfSummary(df))

    ```

### Exercise 14: Simple descriptive statistics

Use your dataframe ds for the following exercises.

1.  Calculate basic descriptive statistics (minimum, mean, median, and maximum) for the following numeric variables: `BPXSY1` (systolic blood pressure), `BPXDI1` (diastolic blood pressure).
2.  Summarize frequencies and proportions for `bp_category` (blood pressure category) and `smoker_status`.

```{r}
#| code-fold: true
#| code-summary: "Show code exercise 14"
#| output: false

# 1. Calculate basic descriptive statistics (minimum, mean, median, and maximum) for the following numeric variables: BPXSY1 (systolic blood pressure), BPXDI1 (diastolic blood pressure).

## Base R

# BPXSY1 (Systolic blood pressure)
summary(ds$BPXSY1)
min(ds$BPXSY1, na.rm = TRUE)
mean(ds$BPXSY1, na.rm = TRUE)
median(ds$BPXSY1, na.rm = TRUE)
max(ds$BPXSY1, na.rm = TRUE)

# BPXDI1 (Diastolic blood pressure)
summary(ds$BPXDI1)
min(ds$BPXDI1, na.rm = TRUE)
mean(ds$BPXDI1, na.rm = TRUE)
median(ds$BPXDI1, na.rm = TRUE)
max(ds$BPXDI1, na.rm = TRUE)


## tidyverse

ds %>% # specifying for each variable on its own
  summarize(
    Min_Systolic = min(BPXSY1, na.rm = TRUE),
    Mean_Systolic = mean(BPXSY1, na.rm = TRUE),
    Median_Systolic = median(BPXSY1, na.rm = TRUE),
    Max_Systolic = max(BPXSY1, na.rm = TRUE),
    Min_Diastolic = min(BPXDI1, na.rm = TRUE),
    Mean_Diastolic = mean(BPXDI1, na.rm = TRUE),
    Median_Diastolic = median(BPXDI1, na.rm = TRUE),
    Max_Diastolic = max(BPXDI1, na.rm = TRUE)
  )


ds %>% # using summarize across
  summarize(
      across(
        c(BPXSY1, BPXDI1),
          list(
            Min = ~ min(.x, na.rm = TRUE),
            Mean = ~ mean(.x, na.rm = TRUE),
            Median = ~median(.x, na.rm = TRUE),
            Max =  ~max(.x, na.rm = TRUE)
          ),
        .names = "{.col}_{.fn}")
     )



## summarytools
descr(ds$BPXSY1)
descr(ds$BPXDI1)




# 2. Summarize frequencies and proportions for bp_category (blood pressure category) and smoker_status.


## Base R

# Frequency and proportions for bp_category
table(ds$bp_category)
prop.table(table(ds$bp_category))

# Frequency and proportions for smoker_status
table(ds$smoker_status)
prop.table(table(ds$smoker_status))




## tidyverse

# Frequency and proportions for bp_category
ds %>%
  count(bp_category) %>%
  mutate(Proportion = n / sum(n))

# Frequency and proportions for smoker_status
ds %>%
  count(smoker_status) %>%
  mutate(Proportion = n / sum(n))


## summarytools
freq(ds$bp_category)
freq(ds$smoker_status)


## Tasks 1 & 2 together

# using table1
table1(~ BPXSY1 + BPXDI1 + bp_category + smoker_status,
       data = ds)

# using summarytools
dfSummary(ds)

```

## Visual inspection

While descriptive statistics are helpful, any exploratory data analysis requires visual inspection to

-   explore variable distributions
-   assess the spread of data and outliers
-   examine relationships between two numeric variables
-   visualize categorical data

**Note on visualizations**: For better customization and aesthetics, **ggplot2** can all charts we show below and much more with enhanced visual appeal, combining different data types and layers. However, if you want to just have a quick visualization of your data, Base R is often quicker and faster. Due to the complexity of ggplot2, we won't go there today, but we strongly recommend to check it out if you want to create figures for publications.

### Histograms

Histograms display the distribution of a numeric variable by dividing it into intervals (bins) and showing the frequency of observations in each interval.

```{r}

# Basic version
hist(df$BMI)

# Plot with some specifications
hist(
  df$BMI,
  main = "Distribution of BMI",
  xlab = "BMI",
  col = "skyblue",
  border = "white"
)
```

### Boxplots

Boxplots summarize the distribution of a numeric variable, highlighting median, quartiles, and potential outliers.

```{r}

# Basic boxplot
boxplot(df$BMI)

# Boxplot stratified and adapted (BMI by age group)
boxplot(
  BMI ~ age_group_three,
  data = df,
  main = "BMI by Gender",
  xlab = "Age group",
  ylab = "BMI",
  col = c("lightblue", "lightgreen", "lightyellow")
)


```

### Scatterplot

Scatterplots are used to explore relationships between two numeric variables.

```{r}

# Basic scatterplot
plot(df$BMXHT, df$BMXWT)

# Scatterplot with some specifications
plot(
  df$BMXHT, df$BMXWT,
  main = "Scatterplot Height vs. Weight",
  xlab = "Height (cm)",
  ylab = "Weight (kg)",
  col = "darkgreen",
  pch = 19 # with this number you can specify the shape of the points
)

```

### Bar charts

Bar charts are used to visualize frequencies of categorical variables.

```{r}

# Basic bar chart
barplot(table(df$BMI_category))

# Bar chart with some specifications
barplot(table(df$BMI_category),
  main = "BMI Categories",
  xlab = "BMI Category",
  ylab = "Count",
  col = c("orange", "yellow", "red", "green")
)


```

### Exercise 15: Visualizations

1.  Create a histogram for `BPXSY1` (systolic blood pressure).
2.  Create a boxplot for `BPXSY1` (diastolic blood pressure) and stratify by `smoker_status`. Title the figure "Blood pressure and smoker status". Label the x-axis "Smoking status", the y-axis "Systolic blood pressure". Color the boxplots in blue and yellow.
3.  Create a scatterplot showing the relationship between `BPXSY1` (systolic blood pressure) and `BPXDI1` (diastolic blood pressure).
4.  Create a bar chart for `bp_category` (blood pressure category).

```{r}
#| code-fold: true
#| code-summary: "Show code exercise 15"
#| output: false

# 1. Create a histogram for BPXSY1 (systolic blood pressure).
hist(ds$BPXSY1)

# 2. Create a boxplot for BPXSY1 (diastolic blood pressure) and stratify by smoker_status. Title the figure "Blood pressure and smoker status". Label the x-axis "Smoking status", the y-axis "Systolic blood pressure". Color the boxplots in blue and yellow.
boxplot(
  BPXSY1 ~ smoker_status,
  data = ds,
  main = "Blood pressure and smoker status",
  xlab = "Smoker status",
  ylab = "Systolic blood pressure",
  col = c("blue", "yellow")
  
)


# 3. Create a scatterplot showing the relationship between BPXSY1 (systolic blood pressure) and BPXDI1 (diastolic blood pressure).
plot(ds$BPXSY1, ds$BPXDI1)

# 4. Create a bar chart for bp_category (blood pressure category).
barplot(table(ds$bp_category))


```

## Descriptives by group

Sometimes you may want to explore descriptives separately for groups. We will go through

-   grouping data by one or more categorical variables.

<!-- -->

-   calculate descriptive statistics (e.g., mean, median) for numeric variables within groups

-   optionally include statistical tests for group differences

### Examples

tidyverse and table1 are two helpful packages for calculating descriptives for each group.

-   **tidyverse**: In tidyverse, you can use the group_by() function to arrange data based upon a factor variable (e.g., age group), and to then calculate descriptives for each group.

    ```{r}

    # Grouped summaries for BMI and BMXWT by age group

    df %>%
      group_by(age_group_three) %>%
      summarize(
        Mean_BMI = mean(BMI, na.rm = TRUE),
        Median_BMI = median(BMI, na.rm = TRUE),
        Mean_Weight = mean(BMXWT, na.rm = TRUE),
        Median_Weight = median(BMXWT, na.rm = TRUE),
        Count = n()
      )
    ```

-   **table1**: You can also use table 1 to stratify calculations by certain groups, using the "\|" operator.

    ```{r}

    # Summary table for BMI and BMXWT grouped by age_group and with testing

    table1(~ BMI + BMXWT | age_group_three,
           data = df)

    ```

### Exercise 16: Descriptives by group

1.  Use tidyverse to
    -   filter for participants without missings for `BPXSY1`

    -   group the dataset by `bp_category`

    -   calculate the mean and median for `BPXSY1` (systolic blood pressure)
2.  Using table1, create a summary table for `pulse_pressure` stratified by `RIAGENDR`.

```{r}
#| code-fold: true
#| code-summary: "Show code exercise 16"
#| output: false

# 1. Use tidyverse to filter for participants without missings for BPXSY1, group the dataset by bp_category calculate the mean and median for BPXSY1 (systolic blood pressure)

ds %>%
  filter(!is.na(BPXSY1)) %>%
  group_by(bp_category) %>%
  summarize(
    mean_Systolic = mean(BPXSY1, na.rm = TRUE),
    median_Systolic = median(BPXSY1, na.rm = TRUE),
    count = n()
  )


# 2. Using table1, create a summary table for pulse_pressure stratified by RIAGENDR

table1(~ pulse_pressure | RIAGENDR,
       data = ds)
```

## Cross-tabulations

To assess associations between categorical variables, you need contigency tables or cross-tabulations. To do those, you can again work with Base R, tidyverse, and summarytools.

### Examples

-   **Base R**

    ```{r}

    # Frequency table of age_group and BMI_category
    table(df$age_group_three, df$BMI_category)

    # Proportion table
    prop.table(table(df$age_group_three, df$BMI_category), margin = 1)
    # margin = 1 gives you row-wise proportions, margin = 2 column-wise proportions

    ```

-   **table1**

    ```{r}

    # BMI category by age group
    table1(~ BMI_category | age_group_three,
           render.missing = NULL, # take this out if you also want to see the missings
           data = df)

    ```

-   **summarytools**

    ```{r}

    # BMI category by age group
    ctable(df$BMI_category, df$age_group_three, prop = "r")

    # You can also drop missing, use column percentages and add a chi-square test
    ctable(df$BMI_category, df$age_group_three,
           useNA = "no",
           prop = "c",
           chisq = TRUE)

    ```

### Exercise 17: Cross-tabulations

Using your dataset ds, create a contigency table of `bp_category` and `smoker_status`. Calculate column-percentages, and run a chi-square test (remember to drop missings for the chi-square test).

```{r}
#| code-fold: true
#| code-summary: "Show code exercise 17"
#| output: false

# Cross-tabulation with ctable of bp_category and smoker_status
ctable(ds$bp_category, ds$smoker_status, prop = "c", useNA = "no", chisq = TRUE)
```
